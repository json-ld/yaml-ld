<!DOCTYPE html>
<html lang="en">
<head>
<title>YAML-LD</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script class='remove'>
  var respecConfig = {
    specStatus: "CG-DRAFT",
    copyrightStart:    "2020",
    shortName:  "yaml-ld",
    edDraftURI: "https://json-ld.github.io/yaml-ld/",
    github: {
      repoURL: "https://github.com/json-ld/yaml-ld/",
        branch: "main"
    },
    doJsonLd:   true,
    editors: [{
        name: "JSON-LD Community"
    }],

    localBiblio: {
      "I-D.ietf-httpapi-yaml-mediatypes": {
        title: "YAML Media Type",
        href: "https://datatracker.ietf.org/doc/draft-ietf-httpapi-yaml-mediatypes/",
        publisher: "IETF",
        date: "2022-06-23",
        status: "WG Document",
        authors: [
          "Roberto Polli",
          "Erik Wilde",
          "Eemeli Aro"
        ]
      },
    },

    // Cross-reference definitions
    xref: ["json-ld11", "json-ld11-api", "json-ld11-framing"],

    group: "cg/json-ld",
    wgPublicList: "public-linked-json",
    maxTocLevel:        4,
  };
</script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Add example button selection logic
    for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
      button.onclick = () => {
        const ex = button.closest(".ds-selector-tabs");
        ex.querySelector("button.selected").classList.remove("selected");
        ex.querySelector(".selected").classList.remove("selected");
        button.classList.add('selected');
        ex.querySelector("." + button.dataset.selects).classList.add("selected");
      }
    }

    // Toggle show/hide changes
    for (const elem of document.querySelectorAll(".show-changes")) {
      elem.onclick = () => {
        if (elem.classList.contains("selected")) {
          // Remove highlight class from elements having "changed" class
          elem.classList.remove("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.remove("highlight");
          }
        } else {
          // Add highlight class to elements having "changed" class
          elem.classList.add("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.add("highlight");
          }
        }
      }
    }
  });
</script>
<style>
  .hidden { display: none;}
  .hl-bold { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
  table.example {width: 100%;}
  .example > pre.context:before {
    content: "Context";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.frame:before {
    content: "Frame";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.input:before {
    content: "Input";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.result:before {
    content: "Result";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.flattened:before {
    content: "Flattened";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.expanded:before {
    content: "Expanded";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.turtle:before {
    content: "Turtle";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  aside.example {
    overflow-y: hidden;
  }
  /* example tab selection */
  .ds-selector-tabs {
    padding-bottom: 2em;
  }
  .ds-selector-tabs .selectors {
    padding: 0;
    border-bottom: 1px solid #ccc;
    height: 28px;
  }
  .ds-selector-tabs .selectors button {
    display: inline-block;
    min-width: 54px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    height: 27px;
    padding: 0 8px;
    line-height: 27px;
    transition: all,0.218s;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    color: #666;
    border: 1px solid transparent;
  }
  .ds-selector-tabs .selectors button:first-child {
    margin-left: 2px;
  }
  .ds-selector-tabs .selectors button.selected {
    color: #202020 !important;
    border: 1px solid #ccc;
    border-bottom: 1px solid #fff !important;
  }
  .ds-selector-tabs .selectors button:hover {
    background-color: transparent;
    color: #202020;
    cursor: pointer;
  }
  .ds-selector-tabs pre:not(.preserve), .ds-selector-tabs table:not(.preserve) {
    display: none;
  }
  .ds-selector-tabs pre.selected, .ds-selector-tabs table.selected {
    display: block;
  }
  a.playground {
    display: inline-block;
    width: 150px;
    border: 1px solid transparent;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    background-color: rgb(192, 192, 192);
    text-decoration: none;
    font-size: 13px;
    margin-bottom: 10px;
  }
  a[href].playground {
    padding: 4px 0 3px 8px;
    border-bottom: none;
    text-decoration: none;
    color: #666;
  }
  .algorithm ol {
    counter-reset: numsection;
    list-style-type: none;
  }
  .algorithm ol>li {
    margin: 0.5em 0;
  }
  .algorithm ol>li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
</style>
</head>
  <body>
    <section id='abstract'>
      <p>
        In recent years, YAML emerged as a more concise format
        to represent information serialized as JSON,
        including Linked Data.
        This document defines how to serialize linked data
        in YAML documents.
        Moreover, it registers the application/ld+yaml media type.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is an unofficial proposal.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        JSON-LD is a JSON-based format to serialize Linked Data.
        In recent years, YAML emerged as a more concise format
        to represent information serialized as JSON,
        including API specification, data schemas, and Linked Data.
      </p>
      <p>
        Since YAML is more expressive than JSON,
        both in the available data types and in the document structure
        (see [[I-D.ietf-httpapi-yaml-mediatypes]]),
        this document identifies constraints on YAML documents
        such that they can be used to represent JSON-LD documents.
      </p>
    </section>

  <section id="conformance">
    <p>A <a>YAML-LD document</a> complies with this specification if ...</p>
    <p class="ednote">Define <dfn>YAML-LD document</dfn> somewhere.</p>

    <p>This specification makes use of the following namespace prefixes:</p>
    <table class="simple">
      <thead><tr>
        <th>Prefix</th>
        <th>IRI</th>
      </tr></thead>
      <tbody>
        <tr>
          <td>ex</td>
          <td>http://example.org/</td>
        </tr>
        <tr>
          <td>rdf</td>
          <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
        </tr>
        <tr>
          <td>xsd</td>
          <td>http://www.w3.org/2001/XMLSchema#</td>
        </tr>
      </tbody>
    </table>

    <p>These are used within this document as part of a <a data-cite="JSON-LD11#dfn-compact-iri">compact IRI</a>
      as a shorthand for the resulting <a data-cite="rfc3987#section-2">IRI</a>, such as <code>dcterms:title</code>
      used to represent <code>http://purl.org/dc/terms/title</code>.</p>
  </section>

  <section id="basic-concepts" class="informative">
    <h2>Basic Concepts</h2>

    <p>
      To ease writing and collaborating on JSON-LD documents, it is a common practice
      to serialize them as YAML.
      This requires a registered media type, not only to enable content negotiation
      of linked data documents in YAML, but even to define the expected behavior of
      applications that processes these documents, including fragment identifiers and
      interoperability considerations.
    </p>

    <p>
      This is because YAML is more flexible than JSON:
    </p>

      <ul>
        <li>YAML supports different encodings, including UTF-8, UTF-16, and UTF-32.</li>
        <li>YAML supports more data types than JSON.</li>
        <li>the structure of a YAML document &mdash; that is, a named YAML representation graph &mdash;
        is a rooted, directed graph that can have cycles.</li>

    <p>
      The first goal of this specification is to allow a JSON-LD document to be
      processed and serialized into YAML, and then back into JSON-LD, without
      losing any information.

      This is always possible, because a YAML representation graph can always represent
      a tree, because JSON data types are a subset of YAML's, and because
      JSON encoding is UTF-8.
    </p>

    <p data-format="markdown>Example: the JSON-LD document below

    ```
    {
      "@context": "http://example.org/context.jsonld",
      "@graph": [
        {"@id": "http://example.org/1", "title": "Example 1"},
        {"@id": "http://example.org/2", "title": "Example 2"},
        {"@id": "http://example.org/3", "title": "Example 3"}
      ]
    }
    ```

    can be serialized as YAML as follows.
    Note that entries 
    starting with  `@` need to be enclosed in quotes or escaped because
    `@` is a reserved character in YAML.

    ```yaml
    %YAML 1.2
    ---
    "@context": http://example.org/context.jsonld
    \@graph:
      -
        "@id": http://example.org/1
        title: Example 1
      -
        \@id: http://example.org/2
        title: Example 2
      -
        '@id': http://example.org/3
        title: Example 3
    ```


    </p>
  </section>
  <section id="specifications" class="normative">
    <h2>Core Requirements</h2>

    <p>
      A YAML-LD document is a [[YAML]] document that can be interpreted as Linked Data [[LINKED-DATA]].
    </p>
    <p>
      It MUST be encoded in UTF-8, to ensure interoperability with [[JSON]]. 
    </p>
    <p>
      Comments in YAML-LD documents
      are treated as white space
      This behavior is consistent with other
      Linked Data serializations like [[TURTLE]].
      See Interoperability considerations of [[I-D.ietf-httpapi-yaml-mediatypes]]
      for more details.
    </p>
    <p>
      Since named anchors are a serialization detail,
      such names
      MUST NOT be used to convey relevant information,
      MAY be altered when processing the document,
      and MAY be dropped when interpreting the document as JSON-LD.
    </p>
    <p> 
      A YAML-LD document MAY contain named anchors and alias nodes, 
      but its representation graph MUST NOT contain cycles.
      When interpreting the document as JSON-LD,
      alias nodes MUST be resolved by value to their target nodes.
    </p>
    <p data-format="markdown">
      Example: The following YAML-LD document
      contains alias nodes for the `{"@id": "country:ITA"}` object:

      ```yaml
      %YAML 1.2
      ---
      "@context":
        "@vocab": "http://schema.org/"
        "countries": "http://publication.europa.eu/resource/authority/country/"
      "@graph":
      - &ITA
        "@id": countries:ITA
      - "@id": http://people.example/Homer
        name: Homer Simpson
        nationality: *ITA
      - "@id": http://people.example/Lisa
        name: Lisa Simpson
        nationality: *ITA
      ```

      While the representation graph (and eventually the in-memory representation
      of the data structure, e.g., a Python dictionary or a Java hashmap) will still
      contain references between nodes, the JSON-LD serialization will not.

      ```json
      {
        "@context": {
          "@vocab": "http://schema.org/",
          "countries": "http://publication.europa.eu/resource/authority/country/"
        },
        "@graph": [
          {
            "@id": "countries:ITA"
          },
          {
            "@id": "http://people.example/Homer",
            "full_name": "Homer Simpson",
            "country": {
              "@id": "countries:ITA"
            }
          },
          {
            "@id": "http://people.example/Lisa",
            "full_name": "Lisa Simpson",
            "country": {
              "@id": "countries:ITA"
            }
          }
        ]
      }
      ```
    </p>
  </section>
  <section id="sec" class="informative">
    <h2>Security Considerations</h2>

    <p>See <a data-cite="JSON-LD11##iana-security">Security considerations in JSON-LD 1.1</a>.
      Also, see the YAML media type registration.</p>
  </section>

  <section id="int" class="informative">
    <h2>Interoperability Considerations</h2>

    <p>
      For general interoperability considerations on the serialization of
      JSON documents in YAML, see [[YAML]]
      and the Interoperability consideration of application/yaml [[I-D.ietf-httpapi-yaml-mediatypes]]..
    </p>
        
  </section>

  <section id="iana" class="appendix normative">
    <h2>IANA Considerations</h2>

    <p>This section has been submitted to the Internet Engineering Steering
      Group (IESG) for review, approval, and registration with IANA.</p>

    <h3>application/ld+yaml</h3>
    <dl>
      <dt>Type name:</dt>
      <dd>application</dd>
      <dt>Subtype name:</dt>
      <dd>ld+yaml</dd>
      <dt>Required parameters:</dt>
      <dd>N/A</dd>
      <dt>Optional parameters:</dt>
      <dd>
        <dl>
          <dt><code>profile</code></dt>
          <dd>
            <p>A non-empty list of space-separated URIs identifying specific
              constraints or conventions that apply to a YAML-LD document according to [[RFC6906]].
              A profile does not change the semantics of the resource representation
              when processed without profile knowledge, so that clients both with
              and without knowledge of a profiled resource can safely use the same
              representation. The <code>profile</code> parameter MAY be used by
              clients to express their preferences in the content negotiation process.
              If the profile parameter is given, a server SHOULD return a document that
              honors the profiles in the list which it recognizes,
              and MUST ignore the profiles in the list which it does not recognize.
              It is RECOMMENDED that profile URIs are dereferenceable and provide
              useful documentation at that URI. For more information and background
              please refer to [[RFC6906]].</p>
            <p>This specification allows the use of the `profile` parameters listed in
              <a data-cite="JSON-LD11##iana-considerations"> and additionally defines the following:</a>
            </p>
            <dl>
              <dt><code>http://www.w3.org/ns/json-ld#extended</code></dt>
              <dd>To request or specify <a data-lt="extended document form">extended YAML-LD document form</a>.
                <div class="ednote">
                  This is a placeholder for specifying something like an
                  <dfn data-lt="extended-document-form">extended YAML-LD document form</dfn>
                  making use of YAML-specific features.
                </div></dd>
            </dl>
            <p>
              When used as a <a data-cite="RFC4288#section-4.3">media type parameter</a> [[RFC4288]]
              in an <a data-cite="rfc9110#rfc.section.12.5.1">HTTP Accept header field</a> [[RFC9110]],
              the value of the <code>profile</code> parameter MUST be enclosed in quotes (<code>"</code>) if it contains
              special characters such as whitespace, which is required when multiple profile URIs are combined.</p>
            <p>When processing the "profile" media type parameter, it is important to
              note that its value contains one or more URIs and not IRIs. In some cases
              it might therefore be necessary to convert between IRIs and URIs as specified in
              <a data-cite="RFC3986#section-5.1">section 3 Relationship between IRIs and URIs</a>
              of [[RFC3987]].</p>
          </dd>
        </dl>
      </dd>
      <dt>Encoding considerations:</dt>
      <dd>See <a data-cite="I-D.ietf-httpapi-yaml-mediatypes">YAML media type</a>.</dd>
      <dt id="iana-security">Security considerations:</dt>
      <dd>See <a href="#sec" class="sectionRef"></a>.</dd>
      <dt>Interoperability considerations:</dt>
      <dd>See <a href="#int" class="sectionRef"></a>.</dd>
      <dt>Published specification:</dt>
      <dd>http://www.w3.org/TR/yaml-ld</dd>
      <dt>Applications that use this media type:</dt>
      <dd>Any programming environment that requires the exchange of
        directed graphs. Implementations of YAML-LD have been created for
        <span class="ednote">FIXME</span>.
      </dd>
      <dt>Additional information:</dt>
      <dd>
        <dl>
          <dt>Magic number(s):</dt>
          <dd>See application/yaml</dd>
          <dt>File extension(s):</dt>
          <dd>.yamlld</dd>
          <dt>Macintosh file type code(s):</dt>
          <dd>TEXT</dd>
        </dl>
      </dd>
      <dt>Person &amp; email address to contact for further information:</dt>
      <dd>Philippe Le HÃ©garet &lt;plh@w3.org&gt;</dd>
      <dt>Intended usage:</dt>
      <dd>Common</dd>
      <dt>Restrictions on usage:</dt>
      <dd>N/A</dd>
      <dt>Author(s):</dt>
      <dd>Roberto Polli, Gregg Kellogg</dd>
      <dt>Change controller:</dt>
      <dd>W3C</dd>
    </dl>

    <section id="frag" class="informative">
      <h2>Fragment identifiers</h2>
      <p>Fragment identifiers used with <a href="#application-ld-yaml">application/ld+yaml</a>
       are treated as in RDF syntaxes, as per
       <a data-cite="RDF11-CONCEPTS#section-fragID">RDF 1.1 Concepts and Abstract Syntax</a>
       [[RDF11-CONCEPTS]].
      </p>

      <p>
        The YAML media type supports both alias nodes and JSON Pointers [[RFC6905]]
        as fragment identifiers (see [[I-D.ietf-httpapi-yaml-mediatypes]]).
        Since named anchors are serialization details, when
        using alias nodes to reference nodes in external documents,
        an implementation needs to be confident that the serialization of
        the resource is preserved.
      </p>

      <div class="ednote">Perhaps more on fragment identifiers from <a href="https://github.com/json-ld/yaml-ld/issues/13">Issue 13</a></div>

    </section>
    <section id="iana-examples" class="informative">
      <h3>Examples</h3>
      <p class="ednote">FIXME</p>
    </section>
  </section>

  <section id="faq" class="informative" data-format="markdown">
    <p class="ednote">REMOVE THIS SECTION BEFORE PUBLICATION.</p>

    <h3>FAQ</h3>

    #### Why does YAML-LD not preserve comments?
    <p class="ednote">
    [[JSON]] (and hence [[JSON-LD]]) does not support comments,
    and other Linked Data serialization formats
    that support comments (such as [[TURTLE]])
    do not provide a means to preserve them
    when processing and serializing the document
    in other formats.
    The proposed behavior is thus consistent with
    other implementations.

    While YAML-LD could define a specific predicate for comments,
    that is insufficient because, for example,
    the order of keywords is not preserved in JSON, so the
    comments could be displaced.
    This specification does not provide a means for preserving
    YAML comments after a JSON serialization.

    ```yaml
    # First comment
    "@context": "http://schema.org"

    # Second comment
    givenName: John
    ```
    
    transforming the above entry into a JSON-LD document
    results in:
    
    ```json
    {
      "@context": "http://schema.org",
      "givenName": "John"
    }
    ```

    
    #### Why does YAML-LD not extend the JSON-LD data model ?
    <p class="ednote">
    [[JSON]] only represents simple trees while [[YAML]] can support
    rooted, directed graphs with references and cycles.

    The above structures cannot be preserved when serializing
    to JSON-LD and - with respect to cycles - the serialization
    will fail.

    Programming languages such as Java and Python already support
    YAML representation graphs, but these implementations may behave
    differently.
    In the following example, `&value` references the value
    of the keyword `value`.

    ```yaml
    value: &value 100
    valve1:
      temperature: &temp100C
        value: *value
        unit: degC
    valve2:
      temperature: *temp100C
    ```

    Processing this entry in Python, I get the following
    structure that preserve the references to
    mutable objects (e.g., the `temperature` dict)
    but not to scalars (e.g., the `value` keyword).

    ```python
    temperature = { "value": 100, "unit": "degC" }
    document = {
      "value": 100,
      "valve1": { "temperature": temperature },
      "valve2": { "temperature": temperature }
    }
    ```

    Since all these implementations pre-date this 
    specification, some more interoperable choices include the following:
    
    * to forbid cycles in YAML-LD documents
    * to consider all references in YAML-LD as static, 
      i.e., a shorthand way to repeat specific patterns

    </p>
  </section>

 </body>
</html>
