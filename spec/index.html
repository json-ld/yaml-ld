<!DOCTYPE html>
<html lang="en">
<head>
<title>YAML-LD</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script src="../common/common.js" class="remove" defer></script>
<script class='remove'>
  var respecConfig = {
    specStatus: "CG-DRAFT",
    copyrightStart:    "2020",
    shortName:  "yaml-ld",
    edDraftURI: "https://json-ld.github.io/yaml-ld/",
    github: {
      repoURL: "https://github.com/json-ld/yaml-ld/",
        branch: "main"
    },
    doJsonLd:   true,
    editors: [{
        name: "JSON-LD Community"
    }],

    localBiblio: {
      "I-D.ietf-httpapi-yaml-mediatypes": {
        title: "YAML Media Type",
        href: "https://datatracker.ietf.org/doc/draft-ietf-httpapi-yaml-mediatypes/",
        publisher: "IETF",
        date: "2022-06-23",
        status: "WG Document",
        authors: [
          "Roberto Polli",
          "Erik Wilde",
          "Eemeli Aro"
        ]
      },

      "json-ld-bp": {
        title: "JSON-LD Best Practices",
        href: "https://w3c.github.io/json-ld-bp/",
        publisher: "W3C",
        date: "2022-05-24",
        status: "W3C Group Note",
        authors: [
          "Gregg Kellogg",
          "Ivan Herman",
          "BigBlueHat",
          "A. Soroka",
          "Ruben Taelman",
          "David I. Lehn",
          "Philippe Le Hegaret",
        ],
      },
    },

    // Cross-reference definitions
    xref: ["json-ld11", "json-ld11-api", "json-ld11-framing"],

    group: "cg/json-ld",
    wgPublicList: "public-linked-json",
    maxTocLevel:        4,
  };
</script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Add example button selection logic
    for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
      button.onclick = () => {
        const ex = button.closest(".ds-selector-tabs");
        ex.querySelector("button.selected").classList.remove("selected");
        ex.querySelector(".selected").classList.remove("selected");
        button.classList.add('selected');
        ex.querySelector("." + button.dataset.selects).classList.add("selected");
      }
    }

    // Toggle show/hide changes
    for (const elem of document.querySelectorAll(".show-changes")) {
      elem.onclick = () => {
        if (elem.classList.contains("selected")) {
          // Remove highlight class from elements having "changed" class
          elem.classList.remove("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.remove("highlight");
          }
        } else {
          // Add highlight class to elements having "changed" class
          elem.classList.add("selected");
          for (const changed of document.querySelectorAll(".changed")) {
            changed.classList.add("highlight");
          }
        }
      }
    }
  });
</script>
<style>
  .hidden { display: none;}
  .hl-bold { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
  table.example {width: 100%;}
  .example > pre.context:before {
    content: "Context";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.frame:before {
    content: "Frame";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.input:before {
    content: "Input";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.result:before {
    content: "Result";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.flattened:before {
    content: "Flattened";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.expanded:before {
    content: "Expanded";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.turtle:before {
    content: "Turtle";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  aside.example {
    overflow-y: hidden;
  }
  /* example tab selection */
  .ds-selector-tabs {
    padding-bottom: 2em;
  }
  .ds-selector-tabs .selectors {
    padding: 0;
    border-bottom: 1px solid #ccc;
    height: 28px;
  }
  .ds-selector-tabs .selectors button {
    display: inline-block;
    min-width: 54px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    height: 27px;
    padding: 0 8px;
    line-height: 27px;
    transition: all,0.218s;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    color: #666;
    border: 1px solid transparent;
  }
  .ds-selector-tabs .selectors button:first-child {
    margin-left: 2px;
  }
  .ds-selector-tabs .selectors button.selected {
    color: #202020 !important;
    border: 1px solid #ccc;
    border-bottom: 1px solid #fff !important;
  }
  .ds-selector-tabs .selectors button:hover {
    background-color: transparent;
    color: #202020;
    cursor: pointer;
  }
  .ds-selector-tabs pre:not(.preserve), .ds-selector-tabs table:not(.preserve) {
    display: none;
  }
  .ds-selector-tabs pre.selected, .ds-selector-tabs table.selected {
    display: block;
  }
  a.playground {
    display: inline-block;
    width: 150px;
    border: 1px solid transparent;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    background-color: rgb(192, 192, 192);
    text-decoration: none;
    font-size: 13px;
    margin-bottom: 10px;
  }
  a[href].playground {
    padding: 4px 0 3px 8px;
    border-bottom: none;
    text-decoration: none;
    color: #666;
  }
  .algorithm ol {
    counter-reset: numsection;
    list-style-type: none;
  }
  .algorithm ol>li {
    margin: 0.5em 0;
  }
  .algorithm ol>li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
</style>
</head>
  <body>
    <section id='abstract'>
      <p>
        In recent years, YAML emerged as a more concise format
        to represent information serialized as JSON,
        including Linked Data.
        This document defines how to serialize linked data
        in YAML.
        Moreover, it registers the application/ld+yaml media type.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is an unofficial proposal.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        JSON-LD is a JSON-based format to serialize Linked Data.
        In recent years, YAML emerged as a more concise format
        to represent information serialized as JSON,
        including API specification, data schemas, and Linked Data.
      </p>
      <p>
        Since YAML is more expressive than JSON,
        both in the available data types and in the document structure
        (see [[I-D.ietf-httpapi-yaml-mediatypes]]),
        this document identifies constraints on YAML
        such that it can be used to represent JSON-LD documents.
      </p>
    </section>

  <section id="conformance">
    <p>A <a>YAML-LD document</a> complies with this specification if ...</p>
    <p class="ednote">Define <dfn>YAML-LD document</dfn> somewhere.</p>
    <p>
      The term media type is imported from [[RFC6838]].
    </p>
    <p>
      The terms JSON, "JSON document", and "JSON string" are imported from [[JSON]].
    </p>
    <p>
      The terms YAML, "YAML document", "YAML representation graph",
      "YAML stream", "YAML directive",
      "node", "scalar",
      "named anchor", and "alias nodes" are imported from [[YAML]].
    </p>
    <p>
      The term "content negotiation" is imported from [[RFC9110]].
    </p>
    <p>
      The terms "fragment" and "fragment identifier" in this document are to be interpreted as in [[URI]].
    </p>
    <p>
      The term "Linked Data" is imported from [[JSON-LD]].
    </p>
    <p>This specification makes use of the following namespace prefixes:</p>
    <table class="simple">
      <thead><tr>
        <th>Prefix</th>
        <th>IRI</th>
      </tr></thead>
      <tbody>
        <tr>
          <td>ex</td>
          <td>http://example.org/</td>
        </tr>
        <tr>
          <td>rdf</td>
          <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
        </tr>
        <tr>
          <td>xsd</td>
          <td>http://www.w3.org/2001/XMLSchema#</td>
        </tr>
      </tbody>
    </table>

    <p>These are used within this document as part of a <a data-cite="JSON-LD11#dfn-compact-iri">compact IRI</a>
      as a shorthand for the resulting <a data-cite="rfc3987#section-2">IRI</a>, such as <code>dcterms:title</code>
      used to represent <code>http://purl.org/dc/terms/title</code>.
    </p>
  </section>

  <section id="basic-concepts" class="informative">
    <h2>Basic Concepts</h2>

    <p>
      To ease writing and collaborating on JSON-LD documents, it is a common practice
      to serialize them as YAML.
      This requires a registered media type, not only to enable content negotiation
      of linked data documents in YAML, but also to define the expected behavior of
      applications that process these documents, including fragment identifiers and
      interoperability considerations.
    </p>

    <p>
      This is because YAML is more flexible than JSON:
    </p>

    <ul>
      <li>YAML supports different encodings, including UTF-8, UTF-16, and UTF-32.</li>
      <li>YAML supports more native data types than JSON.</li>
      <li>the structure of a YAML document &mdash; that is, a named YAML representation graph &mdash;
      is a rooted, directed graph that can have cycles.</li>
      <li>YAML has the concept of stream, which is a sequence of documents.
          While a stream usually contains one document,
          streams with multiple documents are used to aggregate multiple,
          related, documents into a single file or network stream.
      </li>
    </ul>

    <p>
      The first goal of this specification is to allow a JSON-LD document to be
      processed and serialized into YAML, and then back into JSON-LD, without
      losing any information.

      This is always possible, because a YAML representation graph can always represent
      a tree, because JSON data types are a subset of YAML's, and because
      JSON encoding is UTF-8.
    </p>

    <p>Example: The JSON-LD document below</p>
    <pre class="example json"
         data-transform="updateExample"
         data-result-for="Basic YAML-LD document"
         data-content-type="application/ld+json"
         title="Basic JSON-LD document">
      <!--
      {
        "@context": "http://example.org/context.jsonld",
        "@graph": [
          {"@id": "http://example.org/1", "title": "Example 1"},
          {"@id": "http://example.org/2", "title": "Example 2"},
          {"@id": "http://example.org/3", "title": "Example 3"}
        ]
      }
      -->
    </pre>

    <p>
      Can be serialized as YAML as follows.
      Note that entries
      starting with  `@` need to be enclosed in quotes because
      `@` is a reserved character in YAML.
    </p>

    <pre class="example yaml"
         data-transform="updateExample"
         data-content-type="application/ld+yaml"
         title="Basic YAML-LD document">
      <!--
      %YAML 1.2
      ---
      '@context': http://example.org/context.jsonld
      '@graph':
        -
          '@id': http://example.org/1
          title: Example 1
        -
          '@id': http://example.org/2
          title: Example 2
        -
          '@id': http://example.org/3
          title: Example 3
      -->
    </pre>

    <p>
      This document is based on YAML 1.2.2,
      but YAML-LD is not tied to a specific version of [[YAML]].
      Implementers concerned about features related to a specific YAML version
      can specify it in documents using the `%YAML` directive
      (see <a href="#int" class="sectionRef"></a>).
    </p>

    <p>FIXME.</p>
  </section>
  <section id="specifications" class="normative">
    <h2>Core Requirements</h2>

    <p>
      A YAML-LD stream is a YAML stream of YAML-LD documents.
      Note that each document in a stream is independent
      from the others;
      each one has its own context, YAML directives,
      named anchors, and so on.
    </p>
    <p>
      A YAML-LD document is a [[YAML]] document
      that can be interpreted as Linked Data [[LINKED-DATA]].
    </p>
    <p>
      It MUST be encoded in UTF-8, to ensure interoperability with [[JSON]].
    </p>
    <p>
      Comments in YAML-LD documents
      are treated as white space.
      This behavior is consistent with other
      Linked Data serializations like [[TURTLE]].
      See Interoperability considerations of [[I-D.ietf-httpapi-yaml-mediatypes]]
      for more details.
    </p>
    <p>
      Since named anchors are a serialization detail,
      such names
      MUST NOT be used to convey relevant information,
      MAY be altered when processing the document,
      and MAY be dropped when interpreting the document as JSON-LD.
    </p>
    <p>
      A YAML-LD document MAY contain named anchors and alias nodes,
      but its representation graph MUST NOT contain cycles.
      When interpreting the document as JSON-LD,
      alias nodes MUST be resolved by value to their target nodes.
    </p>

    <div data-format="markdown">
      Example: The following YAML-LD document
      contains alias nodes for the `{"@id": "countries:ITA"}` object:

      <pre class="example yaml"
           data-transform="updateExample"
           data-content-type="application/ld+yaml"
           title="YAML-LD with named anchors">
         <!--
          %YAML 1.2
          ---
          "@context":
            "@vocab": "http://schema.org/"
            "countries": "http://publication.europa.eu/resource/authority/country/"
          "@graph":
          - &ITA
            "@id": countries:ITA
          - "@id": http://people.example/Homer
            name: Homer Simpson
            nationality: *ITA
          - "@id": http://people.example/Lisa
            name: Lisa Simpson
            nationality: *ITA
        -->
      </pre>

      While the representation graph (and eventually the in-memory representation
      of the data structure, e.g., a Python dictionary or a Java hashmap) will still
      contain references between nodes, the JSON-LD serialization will not.

      <pre class="example json"
           data-transform="updateExample"
           data-result-for="YAML-LD with named anchors"
           data-content-type="application/ld+json"
           title="JSON-LD resulting from YAML with named anchors">
        <!--
        {
          "@context": {
            "@vocab": "http://schema.org/",
            "countries": "http://publication.europa.eu/resource/authority/country/"
          },
          "@graph": [
            {
              "@id": "countries:ITA"
            },
            {
              "@id": "http://people.example/Homer",
              "full_name": "Homer Simpson",
              "country": {
                "@id": "countries:ITA"
              }
            },
            {
              "@id": "http://people.example/Lisa",
              "full_name": "Lisa Simpson",
              "country": {
                "@id": "countries:ITA"
              }
            }
          ]
        }
        -->
      </pre>
    </div>
  </section>
  <section id="sec" class="informative">
    <h2>Security Considerations</h2>

    <p>See <a data-cite="JSON-LD11##iana-security">Security considerations in JSON-LD 1.1</a>.
      Also, see the YAML media type registration.</p>
  </section>

  <section id="int" class="informative">
    <h2>Interoperability Considerations</h2>

    <p>
      For general interoperability considerations on the serialization of
      JSON documents in YAML, see [[YAML]]
      and the Interoperability consideration of application/yaml [[I-D.ietf-httpapi-yaml-mediatypes]]..
    </p>
    <p>
      The YAML-LD format and the media type registration are not restricted to a specific
      version of YAML,
      but implementers that want to use YAML-LD with YAML versions
      other than 1.2.2 need to be aware that the considerations and analysis provided
      here, including interoperability and security considerations, are based
      on the YAML 1.2.2 specification.
    </p>
  </section>

  <section id="iana" class="appendix normative">
    <h2>IANA Considerations</h2>

    <p>This section has been submitted to the Internet Engineering Steering
      Group (IESG) for review, approval, and registration with IANA.</p>
    <p>
      This section describes the information required to register the above media type according to [[RFC6838]]
    </p>

    <h3>application/ld+yaml</h3>
    <dl>
      <dt>Type name:</dt>
      <dd>application</dd>
      <dt>Subtype name:</dt>
      <dd>ld+yaml</dd>
      <dt>Required parameters:</dt>
      <dd>N/A</dd>
      <dt>Optional parameters:</dt>
      <dd>
        <dl>
          <dt><code>profile</code></dt>
          <dd>
            <p>A non-empty list of space-separated URIs identifying specific
              constraints or conventions that apply to a YAML-LD document according to [[RFC6906]].
              A profile does not change the semantics of the resource representation
              when processed without profile knowledge, so that clients both with
              and without knowledge of a profiled resource can safely use the same
              representation. The <code>profile</code> parameter MAY be used by
              clients to express their preferences in the content negotiation process.
              If the profile parameter is given, a server SHOULD return a document that
              honors the profiles in the list which it recognizes,
              and MUST ignore the profiles in the list which it does not recognize.
              It is RECOMMENDED that profile URIs are dereferenceable and provide
              useful documentation at that URI. For more information and background
              please refer to [[RFC6906]].</p>
            <p>This specification allows the use of the `profile` parameters listed in
              <a data-cite="JSON-LD11##iana-considerations"> and additionally defines the following:</a>
            </p>
            <dl>
              <dt><code>http://www.w3.org/ns/json-ld#extended</code></dt>
              <dd>To request or specify <a data-lt="extended document form">extended YAML-LD document form</a>.
                <div class="ednote">
                  This is a placeholder for specifying something like an
                  <dfn data-lt="extended-document-form">extended YAML-LD document form</dfn>
                  making use of YAML-specific features.
                </div></dd>
            </dl>
            <p>
              When used as a <a data-cite="RFC4288#section-4.3">media type parameter</a> [[RFC4288]]
              in an <a data-cite="rfc9110#rfc.section.12.5.1">HTTP Accept header field</a> [[RFC9110]],
              the value of the <code>profile</code> parameter MUST be enclosed in quotes (<code>"</code>) if it contains
              special characters such as whitespace, which is required when multiple profile URIs are combined.</p>
            <p>When processing the "profile" media type parameter, it is important to
              note that its value contains one or more URIs and not IRIs. In some cases
              it might therefore be necessary to convert between IRIs and URIs as specified in
              <a data-cite="RFC3986#section-5.1">section 3 Relationship between IRIs and URIs</a>
              of [[RFC3987]].</p>
          </dd>
        </dl>
      </dd>
      <dt>Encoding considerations:</dt>
      <dd>See <a data-cite="I-D.ietf-httpapi-yaml-mediatypes#">YAML media type</a>.</dd>
      <dt id="iana-security">Security considerations:</dt>
      <dd>See <a href="#sec" class="sectionRef"></a>.</dd>
      <dt>Interoperability considerations:</dt>
      <dd>See <a href="#int" class="sectionRef"></a>.</dd>
      <dt>Published specification:</dt>
      <dd>http://www.w3.org/TR/yaml-ld</dd>
      <dt>Applications that use this media type:</dt>
      <dd>Any programming environment that requires the exchange of
        directed graphs. Implementations of YAML-LD have been created for
        <span class="ednote">FIXME</span>.
      </dd>
      <dt>Additional information:</dt>
      <dd>
        <dl>
          <dt>Magic number(s):</dt>
          <dd>See application/yaml</dd>
          <dt>File extension(s):</dt>
          <dd>.yamlld</dd>
          <dt>Macintosh file type code(s):</dt>
          <dd>TEXT</dd>
        </dl>
      </dd>
      <dt>Person &amp; email address to contact for further information:</dt>
      <dd>Philippe Le Hégaret &lt;plh@w3.org&gt;</dd>
      <dt>Intended usage:</dt>
      <dd>Common</dd>
      <dt>Restrictions on usage:</dt>
      <dd>N/A</dd>
      <dt>Author(s):</dt>
      <dd>Roberto Polli, Gregg Kellogg</dd>
      <dt>Change controller:</dt>
      <dd>W3C</dd>
    </dl>

    <section id="frag" class="informative">
      <h2>Fragment identifiers</h2>
      <p>Fragment identifiers used with <a href="#application-ld-yaml">application/ld+yaml</a>
       are treated as in RDF syntaxes, as per
       <a data-cite="RDF11-CONCEPTS#section-fragID">RDF 1.1 Concepts and Abstract Syntax</a>
       [[RDF11-CONCEPTS]].
      </p>

      <p>
        The YAML media type supports both alias nodes and JSON Pointers [[RFC6905]]
        as fragment identifiers (see [[I-D.ietf-httpapi-yaml-mediatypes]]).
        Since named anchors are serialization details, when
        using alias nodes to reference nodes in external documents,
        an implementation needs to be confident that the serialization of
        the resource is preserved.
      </p>

      <div class="ednote">Perhaps more on fragment identifiers from <a href="https://github.com/json-ld/yaml-ld/issues/13">Issue 13</a></div>

    </section>
    <section id="iana-examples" class="informative">
      <h3>Examples</h3>
      <p class="ednote">FIXME</p>
    </section>
  </section>

  <section id="faq" class="informative" data-format="markdown">
    <p class="ednote">REMOVE THIS SECTION BEFORE PUBLICATION.</p>

    <h3>FAQ</h3>

    #### Why does YAML-LD not preserve comments?
    <div class="ednote">
    [[JSON]] (and hence [[JSON-LD11]]) does not support comments,
    and other Linked Data serialization formats
    that support comments (such as [[TURTLE]])
    do not provide a means to preserve them
    when processing and serializing the document
    in other formats.
    The proposed behavior is thus consistent with
    other implementations.

    While YAML-LD could define a specific predicate for comments,
    that is insufficient because, for example,
    the order of keywords is not preserved in JSON, so the
    comments could be displaced.
    This specification does not provide a means for preserving
    YAML comments after a JSON serialization.

    <pre class="example yaml"
         data-transform="updateExample"
         data-content-type="application/ld+yaml"
         title="YAML-LD with comments">
      <!--
      # First comment
      "@context": "http://schema.org"

      # Second comment
      givenName: John
      -->
    </pre>

    Transforming the above entry into a JSON-LD document
    results in:

    <pre class="example json"
         data-transform="updateExample"
         data-result-for="YAML-LD with comments"
         data-content-type="application/ld+json"
         title="Result of parsing YAML-LD with comments to JSON-LD">
      <!--
      {
        "@context": "http://schema.org",
        "givenName": "John"
      }
      -->
    </pre>
    </div>

    #### Why does YAML-LD not extend the JSON-LD data model ?
    <div class="ednote">
    [[JSON]] only represents simple trees while [[YAML]] can support
    rooted, directed graphs with references and cycles.

    The above structures cannot be preserved when serializing
    to JSON-LD and - with respect to cycles - the serialization
    will fail.

    Programming languages such as Java and Python already support
    YAML representation graphs, but these implementations may behave
    differently.
    In the following example, `&value` references the value
    of the keyword `value`.

    <pre class="example yaml"
         data-transform="updateExample"
         data-content-type="application/ld+yaml"
         title="YAML-LD with references">
      <!--
      value: &value 100
      valve1:
        temperature: &temp100C
          value: *value
          unit: degC
      valve2:
        temperature: *temp100C
      -->
    </pre>

    Processing this entry in Python, I get the following
    structure that preserve the references to
    mutable objects (e.g., the `temperature` dict)
    but not to scalars (e.g., the `value` keyword).

    <pre class="example python"
         data-transform="updateExample"
         data-result-for="YAML-LD with references"
         data-content-type="text/x-python"
         title="Result of parsing YAML-LD with references to Python">
      <!--
      temperature = { "value": 100, "unit": "degC" }
      document = {
        "value": 100,
        "valve1": { "temperature": temperature },
        "valve2": { "temperature": temperature }
      }
      -->
    </pre>

    Since all these implementations pre-date this
    specification, some more interoperable choices include the following:

    * forbidding cycles in YAML-LD documents
    * considering all references in YAML-LD as static,
      i.e., a shorthand way to repeat specific patterns

    </div>
  </section>
    <section id="best-practices" class="informative">
      <h2>Best Practices</h2>

      <p>Here, we propose to YAML-LD users a bit of advice which, although optional, might suggest one or two
        useful thoughts.</p>

       <div class="practice">
          <p class="practicedesc">
            <span id="use-json-ld-best-practices" class="practicelab">Follow JSON-LD best practices</span>
            …in order to achieve a greater level of reusability, performance, and human friendliness among YAML-LD aware
            systems. The [[json-ld-bp]] document is as relevant to YAML-LD as it is to [[JSON-LD]].
          </p>
       </div>

      <div class="practice">
        <p class="practicedesc">
          <span id="prebuilt-contexts" class="practicelab">Do not force users to author contexts</span>

          Instead, provide pre-built contexts that the user can reference by URL for a majority of common use cases.
        </p>
      </div>

      <p>YAML-LD is intended to simplify the authoring of Linked Data for a wide range of domain experts; its target
        audience is not comprised solely of IT professionals. YAML is chosen as a medium to minimize syntactic noise,
        and to keep the authored documents concise and clear. [[JSON-LD]] (and hence YAML-LD) Context comprises a special
        language of its own. A requirement to <i>author</i> such a context would make the domain expert's job much
        harder &mdash; which we, as system architects and developers, should try to avoid.</p>

      <div class="practice">
        <p class="practicedesc">
          <span id="conceal-contexts" class="practicelab">Use a default context</span>
        </p>

        If most, or all, of a user's documents are based on one particular context, try to make it the default in order
        to rescue the user from copy-pasting the same technical incantation from one document to another.
      </div>

      <p>For instance, according to [[json-ld-api]], the `expand()` method of a JSON-LD processor accepts an
        `expandContext` argument which can be used to provide a default system context.</p>

      <div class="practice">
        <p class="practicedesc">
          <span id="alias-keywords" class="practicelab">Alias JSON-LD keywords</span>

          If possible, map JSON-LD keywords containing the `@` character to keywords that do not contain it.
        </p>
      </div>

      <p>The `@` character is reserved in [[YAML]], and thus requires quoting (or escaping), as in the following
        example:</p>

      <pre class="example json"
          data-transform="updateExample"
          data-content-type="application/ld+yaml"
          title="Example YAML-LD document without Convenience Context">
        <!--
        "@context":
          - https://prefix.cc/context
          - ex: https://example.org/
            name:
              "@id": rdfs:label
              "@container": "@language"
        "@id": ex:Ray
        "@type": ex:Cat
        name:
          en: Ray
          ua: Промiнчик
          ru: Лучик
        -->
      </pre>

      <p>The need to quote these keywords has to be learnt, and introduces one more little irregularity to the document
        author's life. Further, on most keyboard layouts, typing quotes will require `Shift`, which reduces typing speed,
        albeit slightly.</p>

      <p>In order to avoid this, the context might introduce custom mappings for the necessary keywords. For instance,
        [[schema-org]] context redefines `@id` as just `id` — which seems to be much more convenient to type, and
        no more difficult to remember.</p>

       <div class="practice">
          <p class="practicedesc">
            <span id="convenience-context" class="practicelab">Use YAML-LD Convenience Context</span>
            <p>YAML-LD users may use a JSON-LD context provided as part of this specification, henceforth known as the
         <dfn>convenience context</dfn>, which defines a standardized mapping of every `@`-keyword to a `$`-keyword, except `@context`.
         </p>
       </div>

      <aside class="example" title="Convenience Context">
        <p>Code of the <a>convenience context</a>. Available as:
          <a href="https://yaml-ld.dev/context">https://yaml-ld.dev/context</a>.
        </p>
        <p class="ednote">Other contexts go in https://json-ld.org/contexts, we should probably continue to use that</p>
        <pre class="json"
             data-format="application/ld+json"
             data-transform="updateExample">
        <!--
        {
          "@context": {
            "$base": "@base",
            "$container": "@container",
            "$direction": "@direction",
            "$graph": "@graph",
            "$id": "@id",
            "$import": "@import",
            "$included": "@included",
            "$index": "@index",
            "$json": "@json",
            "$language": "@language",
            "$list": "@list",
            "$nest": "@nest",
            "$none": "@none",
            "$prefix": "@prefix",
            "$propagate": "@propagate",
            "$protected": "@protected",
            "$reverse": "@reverse",
            "$set": "@set",
            "$type": "@type",
            "$value": "@value",
            "$version": "@version",
            "$vocab": "@vocab"
          }
        }
        -->
        </pre>
      </aside>

      <p>The <a>convenience context</a> contains an alias to every JSON-LD keyword which the JSON-LD 1.1
        specification permits aliasing &mdash; which means all the keywords except <code>@context</code>. The reserved `@` character is
        replaced by `$`, which is not reserved and therefore does not require quoting. Consider
        <a href="#example-example-yaml-ld-document-without-convenience-context"></a>
         reformatted using the <a>convenience context</a>:</p>

        <pre class="example json"
             data-format="application/ld+json"
             data-transform="updateExample"
             title="Example YAML-LD document with Convenience Context">
        <!--
        "@context":
          - https://prefix.cc/context
          - https://yaml-ld.dev/context
          - ex: https://example.org/
            name:
              $id: rdfs:label
              $container: $language
        $id: ex:Ray
        $type: ex:Cat
        name:
          en: Ray
          ua: Промiнчик
          ru: Лучик
        -->
      </pre>

      <p>The applicability of this context depends on the domain and is left to the architect's best judgement.</p>
  </section>
 </body>
</html>
